let my_tool = require("../my_tool")
let ajax_Â∞ÅË£ÖTt2 = require("./ajax_Â∞ÅË£ÖTt2")
let ajax_Â∞ÅË£Öyr = require("./ajax_Â∞ÅË£Öyr")
let ajax_Â∞ÅË£Öj111 = require("./ajax_Â∞ÅË£Öj111")
let ajax_Â∞ÅË£ÖEr_222 = require("./ajax_Â∞ÅË£ÖEr_222")
let ajax_Â∞ÅË£ÖTt_3333 = require("./ajax_Â∞ÅË£ÖTt_3333")
let ajax_Â∞ÅË£ÖSt_Â∞ÅÈù¢ = require("./ajax_Â∞ÅË£ÖSt_Â∞ÅÈù¢")
let ajax_Â∞ÅË£ÖSt_ÂàÜÁâá = require("./ajax_Â∞ÅË£ÖSt_ÂàÜÁâá")
let Â∑•ÂÖ∑ÊñπÊ≥ï_Ë°®Âçï_‰∏ä‰º†Ê†ºÂºè = require("./Â∑•ÂÖ∑ÊñπÊ≥ï_Ë°®Âçï_‰∏ä‰º†Ê†ºÂºè")
let ajax_Â∞èÁ∫¢‰π¶_ÂèëÂ∏É = require("./ajax_Â∞èÁ∫¢‰π¶_ÂèëÂ∏É")
let Â∑•ÂÖ∑ÊñπÊ≥ï_Ê∂àÊÅØÈòüÂàó = require("./Â∑•ÂÖ∑ÊñπÊ≥ï_Ê∂àÊÅØÈòüÂàó")


// ÂÖ®Â±ÄÂèòÈáè
let my_chunkSize = 5 * 1024 * 1024
let my_video_percent = 10

let callback

function status_listen(cb) {
    callback = cb
}

module.exports = {main, status_listen}



async function main(data) {
    console.log("ÂºÄÂßãÂèëÂ∏É", data)
    const {cookies, video_path, video_duration, img_path, title = "", description = "", topic, ats, address} = data

    // @Â•ΩÂèã---Êï∞ÊçÆÈáçÊñ∞Êï¥ÁêÜÊï∞ÊçÆÂ≠óÊÆµÂêç
    let asts_new = ats.map(o => {
        return JSON.stringify({user_nickname: o.nickname, user_id: o.user_id, image: o.image})
    })

    // Âú∞ÁÇπ---Êï∞ÊçÆÈáçÊñ∞Êï¥ÁêÜÊï∞ÊçÆÂ≠óÊÆµÂêç
    let address_json_str_new = JSON.stringify({name: address.name, poiOid: address.poi_id, subname: address.full_address, source: address.poi_type})


    //ËØùÈ¢ò
    let topic_new = topic.map(o => {
        return JSON.stringify(o)
    })


    // cookies
    globalThis.my_cookie_str = cookies

    // ËßÜÈ¢ëÊï∞ÊçÆ
    let ËßÜÈ¢ë‰ø°ÊÅØ = await my_tool.get_video_info(video_path)
    let ËßÜÈ¢ëÊñá‰ª∂ = my_tool.Make_File_obj(video_path)
    // ÂõæÁâáÊï∞ÊçÆ
    let ÂõæÁâá‰ø°ÊÅØ = require('image-size')(img_path);
    let ÂõæÁâáÊñá‰ª∂ = my_tool.FileBlob(img_path)
    S = {
        videoData: {
            cover: ÂõæÁâáÊñá‰ª∂,//
            width: ÂõæÁâá‰ø°ÊÅØ.width,//
            height: ÂõæÁâá‰ø°ÊÅØ.height,//
            videoType: "horizontal",//
            duration: video_duration,//
            name: ËßÜÈ¢ë‰ø°ÊÅØ.video_name,//
            path: ËßÜÈ¢ë‰ø°ÊÅØ.video_path,//
            size: ËßÜÈ¢ë‰ø°ÊÅØ.video_size,//
            file: ËßÜÈ¢ëÊñá‰ª∂,//
        },//

        // Ë°®Ê†ºÊ†ºÂºè
        formValues: {
            // Â∞ÅÈù¢
            cover: {"value": {"isCropper": true, "url": "", "blob": ÂõæÁâáÊñá‰ª∂, "width": 800, "height": 600}, "required": true, "message": "ËØ∑‰∏ä‰º†Â∞ÅÈù¢"}, //
            // Ê†áÈ¢ò
            title: {"value": title,},//
            //ÂÜÖÂÆπÊèèËø∞
            description: {"value": description},//

            // ËØùÈ¢òÁúüÊ≠£Ê†ºÂºè
            // topic: {value:  ["{\"id\":\"65b0c91100000000020031c6\",\"name\":\"Áî∑ÁîüÂèëÂûãËØùÈ¢ò1\",\"link\":\"https://www.xiaohongshu.com/page/topics/65b0c911e08d1c00015415d5?naviHidden=yes&autoPlayMedioBack=yes\"}"], "required": false},
            topic: {value: topic_new, "required": false},

            // @Â•ΩÂèã
            // friends: {value:["{\"user_nickname\":\"ÂçÅ\",\"user_id\":\"5ca689c90000000010036744\",\"image\":\"https://sns-avatar-qc.xhscdn.com/avatar/5ca68b03a7e4560001154c3a.jpg?imageView2/2/w/80/format/jpg\"}"]  ,   "required": false}, //
            friends: {value: asts_new, "required": false}, //

            // Âú∞ÁÇπ
            // position: {   value:     JSON.stringify(     {name: "Ê≥âÂ∑ûÂ∏àËåÉÂ≠¶Èô¢(‰∏ªÊ†°Âå∫)", poiOid: "B025303BCI", subname: "Ê≥âÂ∑ûÂ∏Ç‰∏∞Ê≥ΩÂå∫‰∏úÊµ∑Â§ßË°ó398Âè∑", source: 12,}        )            ,          "required": false}, //
            position: {value: address_json_str_new, "required": false}, //

            // ÂÖ∂‰ªñÂ≠óÊÆµÊï∞ÁªÑ
            "visible": {"value": 0, "required": true, "message": "ËØ∑ÈÄâÊã©ÊùÉÈôê"},//
            "coverAspectRatio": {"value": {"horizontal": "4:3", "vertical": "3:4"}, "required": false}, "isChangeTitle": {"value": false, "required": false},//
            "isChangeDescription": {"value": false, "required": false}, //
            "publishTime": {"required": false},//
            "isChangePublishTime": {"value": false, "required": false},
        },//


    }
    q = wu()//
    Ne = q(S)
    callback("ËßÜÈ¢ëËß£ÊûêÊàêÂäü")
    await Ne.uploadFile(S.videoData.file)

}


// ÂàùÂßãÂåñÂáΩÊï∞newÁ±ªOe
function wu(R) {
    async function Ëé∑ÂèñÂá≠ËØÅ‰ø°ÊÅØ(S, scene) {
        const res = await ajax_Â∞ÅË£Öyr({cookies: globalThis.my_cookie_str, params: {biz_name: 'spectrum', scene: scene, file_count: 1, version: 1, source: 'web'}})
        const {data} = res.data || {}
        const uploadTempPermits = data?.uploadTempPermits
        if (!uploadTempPermits) {
            throw {...res, message: 'Ëé∑ÂèñÂá≠ËØÅ‰ø°ÊÅØÈîôËØØ'}
        }
        return uploadTempPermits || []
    }

    async function B(S) {
        const {user} = S
        const {videoData, formValues} = user
        if (!videoData?.file) {
            throw Error('ËßÜÈ¢ëÁº∫Â§±')

        }
        if (!formValues?.cover?.value?.blob) {
            throw new Error('ËØªÂèñÂ∞ÅÈù¢Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï')
        }
        if (!formValues?.cover?.value?.width || !formValues?.cover?.value?.height) {
            throw new Error('ËØªÂèñÂ∞ÅÈù¢Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï')
        }
        const [d] = await ajax_Â∞ÅË£Öj111(globalThis.my_cookie_str)
        const fileIds_spectrum = d?.fileIds?.[0]
        const token = d?.token;
        S.fileId = fileIds_spectrum

        S.token = token
        if (videoData.file.size > my_chunkSize) {
            await ajax_Â∞ÅË£ÖEr_222({uploads: '', prefix: fileIds_spectrum}, token)
            const f = await ajax_Â∞ÅË£ÖTt_3333(`https://ros-upload.xiaohongshu.com/${fileIds_spectrum}?uploads=`, {'X-Cos-Security-Token': token, 'Content-Type': 'video/mp4'})
            if (f.data) {
                let my_tool = require("../my_tool")
                let o = await my_tool.XmlStringParse(f.data)
                S.uploadId = o.InitiateMultipartUploadResult.UploadId
            } else {
                throw {...f, message: 'Ëé∑ÂèñuploadId‰∏∫Á©∫'}
            }
        }
    }

    async function N(S, A, b, l) {
        const {fileId: d, uploadId: w, token: v} = b
        const m = {uploadId: w, partNumber: A}

        my_video_percent += 1
        return new Promise((resolve, reject) => {
            // St({route: d, data: S, params: l.length > 1 ? m : void 0, headers: {'X-Cos-Security-Token': v, 'Content-Length': S?.size}})
            let config = {route: d, data: S, params: l.length > 1 ? m : void 0, headers: {'X-Cos-Security-Token': v, 'Content-Length': S?.size}}
            ajax_Â∞ÅË£ÖSt_ÂàÜÁâá(config)
                .then((r) => {
                    const {status: s} = r
                    if (s === 200) {
                        callback("Ê≠£Âú®‰∏ä‰º†ËßÜÈ¢ë")
                        return resolve({params: m, result: r})
                    } else {
                        return reject({...r, message: 'ÂàÜÁâá‰∏ä‰º†Â§±Ë¥•'})
                    }

                })
                .catch((error) => {
                    reject(error)
                })
        })
    }

    async function M(S) {
        const [A] = await Ëé∑ÂèñÂá≠ËØÅ‰ø°ÊÅØ(S, 'image')

        const b = A?.fileIds?.[0]
        let {cover: l} = S?.formValues || {}
        let config = {route: b, data: l?.value?.blob, headers: {'X-Cos-Security-Token': A?.token, 'Content-Length': l?.value?.blob?.size, 'Content-Type': ''}}
        await ajax_Â∞ÅË£ÖSt_Â∞ÅÈù¢(config).catch((error) => {
            throw {...error, message: 'Â§±Ë¥•:Â∞ÅÈù¢‰∏ä‰º†‰∏≠'}
        })

        let result = {coverIds: b, width: l?.value?.width, height: l?.value?.height}
        callback("Ê≠£Âú®‰∏ä‰º†Â∞ÅÈù¢")
        return result
    }

    async function P(S, A) {
        const {fileId: b, uploadId: l, token: d, user: w} = A
        if (Array.isArray(S) && S.length > 1) {
            const f = S.map((p) => {
                const {result: c, params: h} = p
                return h ? {ETag: JSON.parse(c.headers?.etag || ''), PartNumber: h.partNumber} : c.data
            })
            const Êï∞ÊçÆ_ÊñáÊú¨_xml = my_tool.XmlJsonDataToXml("CompleteMultipartUpload", f)


            let config111 = {url: `https://ros-upload.xiaohongshu.com/${b}?uploadId=${l}&aaaaaa=111111`, Êï∞ÊçÆ_ÊñáÊú¨_xml: Êï∞ÊçÆ_ÊñáÊú¨_xml, headers: {'Content-Type': 'application/xml', 'X-Cos-Security-Token': d}}
            let Ê≤°ÊúâË¶ÅÊ±ÇËøîÂõûÂÄº = await ajax_Â∞ÅË£ÖTt2(config111)
        }

        const v = await M(w)
        A.cover = v
        return await x(w, A)
    }

    async function x(S, A) {
        // console.log('üöÄ ÊúÄÁªà‰∏ä‰º†Â∞èÁ∫¢‰π¶Êé•Âè£         :', 111)
        const b = {
            "video": {
                "@type": "Video",
                "StreamOrder": "0",
                "ID": "1",
                "Format": "AVC",
                "Format_Profile": "Main",
                "Format_Level": "3",
                "Format_Settings_CABAC": "Yes",
                "Format_Settings_RefFrames": "1",
                "CodecID": "avc1",
                "Duration": "66.200",
                "BitRate": "884005",
                "Width": "640",
                "Height": "480",
                "Sampled_Width": "640",
                "Sampled_Height": "480",
                "PixelAspectRatio": "1.000",
                "DisplayAspectRatio": "1.333",
                "Rotation": "0.000",
                "FrameRate_Mode": "CFR",
                "FrameRate_Mode_Original": "VFR",
                "FrameRate": "25.000",
                "FrameCount": "1655",
                "ColorSpace": "YUV",
                "ChromaSubsampling": "4:2:0",
                "BitDepth": "8",
                "ScanType": "Progressive",
                "StreamSize": "7315142",
                "Encoded_Date": "UTC 1970-01-01 00:00:00",
                "Tagged_Date": "UTC 1970-01-01 00:00:00",
                "extra": {
                    "CodecConfigurationBox": "avcC"
                }
            }, "audio": {
                "@type": "Audio",
                "StreamOrder": "1",
                "ID": "2",
                "Format": "AAC",
                "Format_AdditionalFeatures": "LC",
                "CodecID": "mp4a-40-2",
                "Duration": "66.198",
                "BitRate_Mode": "VBR",
                "BitRate": "384000",
                "BitRate_Maximum": "449032",
                "Channels": "6",
                "ChannelPositions": "Front: L C R, Side: L R, LFE",
                "ChannelLayout": "C L R Ls Rs LFE",
                "SamplesPerFrame": "1024",
                "SamplingRate": "48000",
                "SamplingCount": "3177504",
                "FrameRate": "46.875",
                "FrameCount": "3103",
                "Compression_Mode": "Lossy",
                "StreamSize": "3176488",
                "StreamSize_Proportion": "0.30165",
                "Default": "Yes",
                "AlternateGroup": "1",
                "Encoded_Date": "UTC 1970-01-01 00:00:00",
                "Tagged_Date": "UTC 1970-01-01 00:00:00"
            }
        }
        let Ë°®Âçï_‰∏ä‰º†Ê†ºÂºè = Â∑•ÂÖ∑ÊñπÊ≥ï_Ë°®Âçï_‰∏ä‰º†Ê†ºÂºè(S.formValues, A, b)
        console.log(`S.formValues---:`, S.formValues)

        let Âä†ÂØÜÂèÇÊï∞xs_xt = my_tool.xhr_get_XS_Xt(Ë°®Âçï_‰∏ä‰º†Ê†ºÂºè)

        const m = {data: Ë°®Âçï_‰∏ä‰º†Ê†ºÂºè, headers: {Authorization: '', 'X-S': Âä†ÂØÜÂèÇÊï∞xs_xt['X-s'], 'X-T': String(Âä†ÂØÜÂèÇÊï∞xs_xt['X-t'])}}
        const res = await ajax_Â∞èÁ∫¢‰π¶_ÂèëÂ∏É({...m, cookies: globalThis.my_cookie_str})
        if (res.data && res.data.success === true) {
            callback("ÂèëÂ∏ÉÊàêÂäü")
            return true
        } else {
            throw {message: 'ÂèëÂ∏ÉÂ§±Ë¥•'}
        }


    }


    const F = (S, A) => {
        console.log(`ÂèëÂ∏ÉÂ§±Ë¥•      S: `, S)
        console.log(`ÂèëÂ∏ÉÂ§±Ë¥•      A: `, A)
    }

    function q(S) {
        let config = {chunkSize: my_chunkSize, context: {user: S}, beforeUpload: B, uploadPartFile: N, uploaded: P, updateProcess: () => 1, onError: F}
        let res = new Oe(config)
        return res
    }

    return q
}


// Á±ªOeËßÜÈ¢ë‰∏ä‰º†
class Oe {
    constructor(U) {
        this.uploadOptions = U
    }

    async uploadFile(videoData_file) {
        const {context, singleUpload, beforeUpload, uploaded, onError: N, runLimit: M = 3} = this.uploadOptions
        const P = this.getChunkList(videoData_file)

        this.uploadStatus = Array(P.length).fill(!1)
        try {
            if (singleUpload) {
                const _ = await singleUpload(videoData_file, context)
                uploaded && await uploaded(_, context)
            } else {
                beforeUpload && (await beforeUpload(context))
                const _ = Â∑•ÂÖ∑ÊñπÊ≥ï_Ê∂àÊÅØÈòüÂàó(M)
                const x = P.map((L, F) => _(() => this.uploadChunkWithRetry(L, F, P)))
                const V = await Promise.all(x)
                uploaded && await uploaded(V, context)

                return V
            }
        } catch (error) {
            // console.error('ÂèëÂ∏ÉÂ§±Ë¥•:', error), N ? N(su(error), O) : console.error('Upload failed:', error)
            throw {message: 'ÂèëÂ∏ÉÂ§±Ë¥•', error}
        }
    }

    getChunkList(vide_File) {
        const {chunkSize} = this.uploadOptions
        const vide_size = vide_File.size
        const j = Math.ceil(vide_size / chunkSize)
        let result = Array.from({length: j}, (N, M) => {
            function Êñá‰ª∂getBlobSlice() {
                if (typeof File.prototype.slice != "function") {
                    throw new Error("The Blob slicing method is not supported in this browser.");
                }

                return File.prototype.slice
            }


            const P = chunkSize * M, _ = Math.min(P + chunkSize, vide_size)
            return {body: Êñá‰ª∂getBlobSlice().call(vide_File, P, _), part: M + 1}
        })


        // console.log('getChunkList--ËøîÂõûÂÄº           result:', result)
        return result
    }

    async uploadChunkWithRetry(U, O, D, j = 0) {
        const {context: B, uploadPartFile: N, retryTimes: M = 3, updateProcess: P} = this.uploadOptions
        try {
            const _ = await N(U.body, U.part, B, D)
            if (((this.uploadStatus[O] = !0), P)) {
                const x = this.uploadStatus.filter((L) => L).length, V = (x / D.length) * 100
                await P(V, x, D.length, B)
            }

            return _
        } catch (error) {
            if (j < M) return this.uploadChunkWithRetry(U, O, D, j + 1)
            throw error
        }
    }
}


